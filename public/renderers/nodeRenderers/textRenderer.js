export const textRenderer = {
  render(node, ctx) {
    const { x, y, width, height } = node.bounds;  // use as-is, let ctx translate handle scrolling
    const {
      font,
      color,
      backgroundColor,
      borderColor,
      paddingX = 0,
      paddingY = 0,
      radius = 0,
      align = "left"
    } = node.style;

    ctx.save();
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textBaseline = "top"; // align y to top of text

    if (backgroundColor) {
      ctx.fillStyle = backgroundColor;
      drawRoundedRect(ctx, x, y, width, height, radius);
      ctx.fill();
      if (borderColor) {
        ctx.strokeStyle = borderColor;
        ctx.stroke();
      }
      ctx.fillStyle = color;
    }

    const lineHeight = node._lineHeight || parseInt(font) * 1.2; // line spacing factor
    let currentY = y + paddingY;

    // Draw each line generated by TextLayoutStrategy
    for (const line of node._lines || [node.text]) {
      let textX = x + paddingX;
      if (align !== "left") {
        const lineWidth = ctx.measureText(line).width;
        if (align === "center") {
          textX = x + (width - lineWidth) / 2;
        } else if (align === "right") {
          textX = x + width - paddingX - lineWidth;
        }
      }

      ctx.fillText(line, textX, currentY);
      currentY += lineHeight;
    }

    ctx.restore();
  }
};

function drawRoundedRect(ctx, x, y, width, height, radius) {
  const r = Math.max(0, Math.min(radius || 0, Math.min(width, height) / 2));
  ctx.beginPath();
  if (r === 0) {
    ctx.rect(x, y, width, height);
    return;
  }
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + width, y, x + width, y + height, r);
  ctx.arcTo(x + width, y + height, x, y + height, r);
  ctx.arcTo(x, y + height, x, y, r);
  ctx.arcTo(x, y, x + width, y, r);
  ctx.closePath();
}
