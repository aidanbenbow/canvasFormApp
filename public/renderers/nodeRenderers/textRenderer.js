export const textRenderer = {
  render(node, ctx) {
    const { x, y, width, height } = node.bounds;  // use as-is, let ctx translate handle scrolling
    const {
      font,
      color,
      backgroundColor,
      borderColor,
      paddingX = 0,
      paddingY = 0,
      radius = 0,
      align = "left"
    } = node.style;

    ctx.save();
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textBaseline = "top"; // align y to top of text

    if (backgroundColor) {
      ctx.fillStyle = backgroundColor;
      drawRoundedRect(ctx, x, y, width, height, radius);
      ctx.fill();
      if (borderColor) {
        ctx.strokeStyle = borderColor;
        ctx.stroke();
      }
      ctx.fillStyle = color;
    }

    const defaultLineHeight = parseInt(font) * 1.2; // line spacing factor
    let currentY = y + paddingY;

    // Draw each line generated by TextLayoutStrategy
    const lines = node._lines || [{ segments: [{ text: node.text, font, color }], width: ctx.measureText(node.text || "").width, height: defaultLineHeight }];
    for (const line of lines) {
      const lineWidth = typeof line.width === "number"
        ? line.width
        : ctx.measureText(line).width;

      let textX = x + paddingX;
      if (align !== "left") {
        if (align === "center") {
          textX = x + (width - lineWidth) / 2;
        } else if (align === "right") {
          textX = x + width - paddingX - lineWidth;
        }
      }

      if (Array.isArray(line.segments)) {
        let cursorX = textX;
        for (const segment of line.segments) {
          if (!segment.text) continue;
          ctx.font = segment.font || font;
          ctx.fillStyle = segment.color || color;
          ctx.fillText(segment.text, cursorX, currentY);
          cursorX += segment.width ?? ctx.measureText(segment.text).width;
        }
      } else {
        ctx.font = font;
        ctx.fillStyle = color;
        ctx.fillText(line, textX, currentY);
      }

      currentY += line.height || defaultLineHeight;
    }

    ctx.restore();
  }
};

function drawRoundedRect(ctx, x, y, width, height, radius) {
  const r = Math.max(0, Math.min(radius || 0, Math.min(width, height) / 2));
  ctx.beginPath();
  if (r === 0) {
    ctx.rect(x, y, width, height);
    return;
  }
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + width, y, x + width, y + height, r);
  ctx.arcTo(x + width, y + height, x, y + height, r);
  ctx.arcTo(x, y + height, x, y, r);
  ctx.arcTo(x, y, x + width, y, r);
  ctx.closePath();
}
